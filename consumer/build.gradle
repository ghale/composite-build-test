// This is only necessary to get the zip4j library
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'net.lingala.zip4j:zip4j:1.3.2'
    }
}

plugins {
    id 'lifecycle-base'
}

// Define some attributes to represent the different ways a dependency can be accessed
def usage = Usage.USAGE_ATTRIBUTE
def packaged = project.objects.named(Usage.class, "packaged_zip")
def extracted = project.objects.named(Usage.class, "extracted_zip")
def extractedHeaders = project.objects.named(Usage.class, Usage.C_PLUS_PLUS_API)
def extractedLibs = project.objects.named(Usage.class, Usage.NATIVE_RUNTIME)

dependencies {
    attributesSchema {
        attribute(usage)
    }
    // All zip files are treated as "packaged" by default
    artifactTypes {
        zip {
            attributes.attribute(usage, packaged)
        }
    }
    // A transform to extract packaged artifacts
    registerTransform {
        from.attribute(usage, packaged)
        to.attribute(usage, extracted)
        artifactTransform(ExtractTransform.class)
    }
    // A transform to find the header dirs in an extracted package
    registerTransform {
        from.attribute(usage, extracted)
        to.attribute(usage, extractedHeaders)
        artifactTransform(HeaderTransform.class)
    }
    // A transform to find the shared libraries in an extracted package
    registerTransform {
        from.attribute(usage, extracted)
        to.attribute(usage, extractedLibs)
        artifactTransform(LibraryTransform.class)
    }
}

configurations {
    compile
    // this configuration represents the extracted headers from the compile configuration
    headers {
        extendsFrom compile
        attributes {
            attribute(usage, extractedHeaders)
        }
    }
    // this configuration represents the extracted libraries from the compile configuration
    libraries {
        extendsFrom compile
        attributes {
            attribute(usage, extractedLibs)
        }
    }
}

dependencies {
    compile dep('producer1', '1.2')
    compile dep('producer2', '1.2')
}

// Creates a Dependency instance configured to consume the zip output of the given project
def dep(String module, String versionSelector) {
    return project.dependencies.create("my.group:${module}:${versionSelector}") {
        artifact {
            name = module
            classifier = 'macos-x86_64'
            type = 'zip'
            extension = 'zip'
        }
    }
}

// Use a file collection to keep track of the extracted headers and libs
// These can be used as input to a compile or link task to take care of the dependency on the extract task
def headerDirs = files()
def sharedLibs = files()

// Attach task dependency information to the file collections
headerDirs.from(configurations.headers)
sharedLibs.from(configurations.libraries)

task genCmake {
    // The generation task uses the headers and libs file collections instead of using configurations.compile directly
    // The task dependency on the extract task travels with these file collections
    inputs.files headerDirs
    inputs.files sharedLibs
    doLast {
        headerDirs.each { f ->
            println "compiling using $f"
        }
        sharedLibs.each { f ->
            println "linking using $f"
        }
    }
}

assemble {
    dependsOn genCmake
}

// We only use the zip4j library here for simplicity (we currently cannot use the Project object in a transform)
import net.lingala.zip4j.core.ZipFile

class ExtractTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        println "extracting $file.name"
        def unzipDir = new File(outputDirectory, file.name)
        ZipFile zipFile = new ZipFile(file)
        zipFile.extractAll(unzipDir.absolutePath)

        return [unzipDir]
    }
}

class HeaderTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        return [new File(file, "headers")]
    }
}

class LibraryTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        return new File(file, "lib").listFiles() as List
    }
}