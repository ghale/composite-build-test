// This is only necessary to get the zip4j library
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'net.lingala.zip4j:zip4j:1.3.2'
    }
}

plugins {
    id 'lifecycle-base'
}

def format = Attribute.of("format", String.class)
def packaged = "packaged"
def extracted = "extracted"
def extractedHeaders = "extractedHeaders"
def extractedLibs = "extractedLibs"

dependencies {
    attributesSchema {
        attribute(format)
    }
    artifactTypes {
        zip {
            attributes.attribute(format, packaged)
        }
    }
    registerTransform {
        from.attribute(format, packaged)
        to.attribute(format, extracted)
        artifactTransform(ExtractTransform.class)
    }
    registerTransform {
        from.attribute(format, extracted)
        to.attribute(format, extractedHeaders)
        artifactTransform(HeaderTransform.class)
    }
    registerTransform {
        from.attribute(format, extracted)
        to.attribute(format, extractedLibs)
        artifactTransform(LibraryTransform.class)
    }
}

configurations {
    compile
    headers {
        extendsFrom compile
        attributes {
            attribute(format, extractedHeaders)
        }
    }
    libraries {
        extendsFrom compile
        attributes {
            attribute(format, extractedLibs)
        }
    }
}

dependencies {
    compile dep('producer1', '1.2')
    compile dep('producer2', '1.2')
}

// Creates a Dependency instance configured to consume the zip output of the given project
def dep(String module, String versionSelector) {
    return project.dependencies.create("my.group:${module}:${versionSelector}") {
        artifact {
            name = module
            classifier = 'macos-x86_64'
            type = 'zip'
            extension = 'zip'
        }
    }
}

// Use a file collection to keep track of the extracted headers and libs
// These can be used as input to a compile or link task to take care of the dependency on the extract task
def headerDirs = files()
def sharedLibs = files()

// Attach task dependency information to the file collections
headerDirs.from(configurations.headers)
sharedLibs.from(configurations.libraries)

task genCmake {
    // The generation task uses the headers and libs file collections instead of using configurations.compile directly
    // The task dependency on the extract task travels with these file collections
    inputs.files headerDirs
    inputs.files sharedLibs
    doLast {
        headerDirs.each { f ->
            println "compiling using $f"
        }
        sharedLibs.each { f ->
            println "linking using $f"
        }
    }
}

assemble {
    dependsOn genCmake
}

import net.lingala.zip4j.core.ZipFile;

class ExtractTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        println "extracting $file.name"
        def unzipDir = new File(outputDirectory, file.name)
        ZipFile zipFile = new ZipFile(file)
        zipFile.extractAll(unzipDir.absolutePath)

        return [unzipDir]
    }
}

class HeaderTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        return [new File(file, "headers")]
    }
}

class LibraryTransform extends ArtifactTransform {
    @Override
    List<File> transform(File file) {
        return new File(file, "lib").listFiles() as List
    }
}